import Vuex, { Store } from 'vuex';
import { {{ properCase singularName }}DefaultState } from '@/store/{{ camelCase singularName }}/state';
import { IState } from '@/interfaces/IState';
import { I{{ properCase singularName }} } from '@/interfaces/I{{ properCase singularName }}';
import { {{ properCase singularName }}Actions } from '@/store/{{ camelCase singularName }}/actions';
import { {{ properCase singularName }}Mutations } from '@/store/{{ camelCase singularName }}/mutations';
import { {{ properCase singularName }}Getters } from '@/store/{{ camelCase singularName }}/getters';
import { AxiosMock, getAxiosMock } from '@/test/test-utils';

describe('{{ properCase singularName }}Actions', () => {
  let store: Store<IState>;
  let axiosMock: AxiosMock;
  let fixture: I{{ properCase singularName }};

  const {{ properCase singularName }}Module = {
    namespaced: true,
    state: () => {{ properCase singularName }}DefaultState(),
    mutations: {{ properCase singularName }}Mutations,
    actions: {{ properCase singularName }}Actions,
    getters: {{ properCase singularName }}Getters,
  };

  beforeEach(() => {
    store = new Vuex.Store({
      modules: {
        {{ camelCase singularName }}: {{ properCase singularName }}Module,
      },
    } as any);

    axiosMock = getAxiosMock();

    store.$axios = axiosMock;
    store.commit = jest.fn();

    fixture = { id: '1' };
  });

  describe('fetch{{ properCase pluralName }}', () => {
    test('it should call SET_{{ constantCase pluralName }} on success', async () => {
      axiosMock.onGet('/{{ camelCase pluralName }}').reply(200, fixture);

      await store.dispatch('{{ camelCase singularName }}/fetch{{ properCase pluralName }}');

      expect(store.commit).toHaveBeenCalledWith('{{ camelCase singularName }}/SET_{{ constantCase pluralName }}', fixture, undefined);
    });

    test('it should throw an error on failure', async () => {
      axiosMock.onGet('/{{ camelCase pluralName }}').reply(500);

      try {
        await store.dispatch('{{ camelCase singularName }}/fetch{{ properCase pluralName }}');
      } catch (e) {
        expect(e.message).toEqual('Request failed with status code 500');
      }
    });
  });

  describe('fetch{{ properCase singularName }}', () => {
    test('it should call SET_CURRENT_{{ constantCase singularName }} on success', async () => {
      axiosMock.onGet('/{{ camelCase pluralName }}/1').reply(200, fixture);

      await store.dispatch('{{ camelCase singularName }}/fetch{{ properCase singularName }}', '1');

      expect(store.commit).toHaveBeenCalledWith('{{ camelCase singularName }}/SET_CURRENT_{{ constantCase singularName }}', fixture, undefined);
    });

    test('it should throw an error on failure', async () => {
      axiosMock.onGet('/{{ camelCase pluralName }}/1').reply(500);

      try {
        await store.dispatch('{{ camelCase singularName }}/fetch{{ properCase singularName }}', '1');
      } catch (e) {
        expect(e.message).toEqual('Request failed with status code 500');
      }
    });
  });

  describe('create{{ properCase singularName }}', () => {
    test('it should call ADD_{{ constantCase singularName }} on success', async () => {
      axiosMock.onPost('/{{ camelCase pluralName }}').reply(200, fixture);

      await store.dispatch('{{ camelCase singularName }}/create{{ properCase singularName }}', fixture);

      expect(store.commit).toHaveBeenCalledWith('{{ camelCase singularName }}/ADD_{{ constantCase singularName }}', fixture, undefined);
    });

    test('it should throw an error on failure', async () => {
      axiosMock.onPost('/{{ camelCase pluralName }}').reply(500);

      try {
        await store.dispatch('{{ camelCase singularName }}/create{{ properCase singularName }}', fixture);
      } catch (e) {
        expect(e.message).toEqual('Request failed with status code 500');
      }
    });
  });

  describe('update{{ properCase singularName }}', () => {
    test('it should call UPDATE_{{ constantCase singularName }} on success', async () => {
      axiosMock.onPut('/{{ camelCase pluralName }}/1').reply(200, fixture);

      await store.dispatch('{{ camelCase singularName }}/update{{ properCase singularName }}', fixture);

      expect(store.commit).toHaveBeenCalledWith('{{ camelCase singularName }}/UPDATE_{{ constantCase singularName }}', fixture, undefined);
    });

    test('it should throw an error on failure', async () => {
      axiosMock.onPut('/{{ camelCase pluralName }}/1').reply(500);

      try {
        await store.dispatch('{{ camelCase singularName }}/update{{ properCase singularName }}', fixture);
      } catch (e) {
        expect(e.message).toEqual('Request failed with status code 500');
      }
    });
  });

  describe('delete{{ properCase singularName }}', () => {
    test('it should call DELETE_{{ constantCase singularName }} on success', async () => {
      axiosMock.onDelete('/{{ camelCase pluralName }}/1').reply(200, fixture);

      await store.dispatch('{{ camelCase singularName }}/delete{{ properCase singularName }}', fixture);

      expect(store.commit).toHaveBeenCalledWith('{{ camelCase singularName }}/DELETE_{{ constantCase singularName }}', fixture, undefined);
    });

    test('it should throw an error on failure', async () => {
      axiosMock.onDelete('/{{ camelCase pluralName }}/1').reply(500);

      try {
        await store.dispatch('{{ camelCase singularName }}/delete{{ properCase singularName }}', fixture);
      } catch (e) {
        expect(e.message).toEqual('Request failed with status code 500');
      }
    });
  });
});
